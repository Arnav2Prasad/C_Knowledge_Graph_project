Intro:
-------------
<p>Detailed Instructions on Project</p>

Content:
-------------
<h4><span style="color: #ff0000; font-size: medium;">Expected features of various projects</span></h4>
<h5><b>* bc</b></h5>
<p>unlimited precision real numbers.<br />operations: + - * / ^  &lt;&lt;   &gt;&gt;    ^   % ; infix calculation with () <br />variables<br />history<br />use of "." <br />sine, cosine, tangent() functions;  <br />(Any other functionality specifically assigned to you)<br />Submission: In addition to code<br />   one text file containing one expression (for which you have checked your code) per line.<br />Also Need to Submit: A file with tested commands - one per line. File named as test.txt <br /><br /></p>
<h5><b>* Graphical Calculator</b></h5>
<p>This one will be done using GTK or QT windowing toolkit libraries. <br />The interface should be like the gnome-calculator program. <br />unlimited precision real numbers. <br />Either Programming Mode or Scientific Mode to be implemented. <br /><br /></p>
<h5>* Compression algorithms</h5>
<p>Minimum two algorithms, as specified to you. <br />The program should be able to compress and decompress any file. <br />Program will run like this: <br /># here the first two commands are for compression and <br /># later two demonstrate decompression<br />./program -c1  &lt;file&gt; &lt;compressed-file-name&gt; <br />./program -c2 &lt;file&gt; &lt;compressed-file-name&gt; <br />./program -uc1 &lt;compressed-file&gt; &lt;uncompressed-file&gt;<br />./program -uc2 &lt;compressed-file&gt; &lt;uncompressed-file&gt;  <br /><br /></p>
<h5><b>* Encryption</b></h5>
<p>The description is exacly like compression. Minimum two algorithms will be specified to you.<br /><br /></p>
<h5><b>* Calendar</b></h5>
<p>See google calender for an example. <br />A calendar application using GTK or QT or SDL. <br />One should be able to see infinite calendar.<br />Views: Daywise, weekwise,  monthly, etc. <br />Functionality: creating events(repeated, non-repeated, etc),  showing calendar for any date-date!, reminders,  saving of calendar, restoring of calendar in ICS format. <br />Submission: Should submit a calendar with some ICS files already in your git repo.<br /><br /></p>
<h5><b>Chain reaction Game: </b></h5>
<p>* M x M board. Configurable by user as difficulty levle.<br />* N human players to be supported<br />* N-1 human and 1 computer player to be supported. <br />* Save and resume a game. Game should be saved to file.  <br /><br /></p>
<h5><b>Chess</b></h5>
<p>* All rules of chess to be implemented properly. <br />* 2 human player mode<br />* 1 human + 1 software/computer player mode <br />* Save and resume a game. Game should be saved to file. <br />* The quality will be determined by quality of the computer player. <br />* Nice and intuitive user interface required in case of terminal based game.<br /><br /></p>
<h5><b>* Quiz</b></h5>
<p>The quiz program, running on command line should have at least following features: <br />creation of a question bank<br />various types of questions: multiple choice (any no. of choices), multiple correct answers, numerical answer questions, match-the-pair;  <br />Selecting questions from question bank for  a quiz; <br />storing a quiz, restoring a quiz, storing a running quiz session, restoring a running quiz-session; exporting the entire question bank, importing the question bank; <br />categorizing questions in question bank.<br /><br /></p>
<h5><b>* File I/O Library</b></h5>
<p>Write an implementation of the given FILE functions using the functions open, read, write, lseek, etc.<br />List of functions: fopen, fclose, fread, fwrite, fgetpos, fsetpos, feof, ftell, fseek<br />Test-suite is required. <br />Guidelines:<br />Read the manual pages completely<br />Try the functions completely to undestand how they work<br />Read stdio.h and see definition of struct FILE<br />Design a data structure to implement the FILF type. Get it checked from Abhijit.<br />Code. <br /><br /></p>
<h5><b>* Heap Manager</b></h5>
<p>Write your own implementation of the malloc, free, realloc, calloc, etc. functions related to memory management.  <br />Test-suite required.<br />Note: The memory allocation functions request a "big chunk" of memory from the OS. For every request by programs to allocate (malloc/calloc/realloc) memory, they take a small portion of this big-chunk, record the location and size, and return the address. When free() is called, they know the size of the chunk from their record. Writing these functions involve handling the problems of internal and external fragmentation (read about them online). Also read slab allocator, budddy allocator, etc. For this you may use the brk() system call.<br /><br /></p>
<h5><b>* Library management</b></h5>
<p>Have a look at the Koha software. Write a library management software like this. Use a graphical interface library like GTK or QT. NOTE, STRONGLY: You need to learn the basics of library science.<br />Functionality expected: See the list of books, seach on author/title/publisher; add books, delete books, update books; each book to have multiple copies; Users; Issue; Requests; Pending Requests; Fine on late return; Export the data as XML and import as XML; <br /><br /></p>
<h5><b>* Logic Gate Simulator</b></h5>
<p>Write a software which allows one to create logic gates, combine them to form different circuits, apply different inputs and see the output. Gates: NOT, AND, NOT, NOR, XNOR, OR, XOR, NAND<br />Use GTK or QT library. <br />Store a diagram in a file. Read the diagram from a file. <br /><br /></p>
<h5><b>* Simulation of sorting algorithms</b></h5>
<p>Write graphical simulation of at least 4 sorting algorithms. Code should support automated and manual data generation/insertion and stepwise execution of sorting algorithms. You can use GTK or QT or Ncurses library. <br /><br /></p>
<h5><b>* Animation of stack, queue, list </b></h5>
<p>Show animation of different implementations of stack, queue and list data types. The code should allow a choice of different implementations of the data structures (array based - multiple techniques, linked-structures with multiple techniques, etc). <br /><br /></p>
<h5><b>* sort command</b></h5>
<p>The sort command sorts any user input or files. It can sort files of any size (e.g. 10G, 100GB, etc.). This requires you to write external sort. <br />Handle following options: -k -n -b  -d  -i  -r  -m  -t -u <br />Also Need to Submit: A file with tested commands - one per line. File named as test.txt <br /><br />* tree command<br />The tree command prints a directory tree vertically, so that it looks like a tree.<br />You need to learn printing techniques using printf (e.g. use of special characters in formatting string, etc.). <br />Your code needs to implement a n-way tree or a nicely done recursive code. <br />Options to be handled: -a  -d  -R --ignore-case  -filelimit  -ofilename   -u -s  -t  -r  -J <br />Difficult option: -p pattern <br />Also Need to Submit: A file with tested commands - one per linne. File named as test.txt <br /><br /></p>
<h5><b>* tar command</b></h5>
<p>The tar program creates a "tarball" from a given set of files and folders. The tarball is a dump of all the files and folders, and also (has to) include metadata about the files/folders. <br />Implment these options:  -c  -v -f  -x  --delete  --append  --update -A  -t <br />Also Need to Submit: A file with tested commands - one per linne. File named as test.txt <br /><br /></p>
<h5>* grep</h5>
<p>Implement these options:  -r  -i  -v  -f  -w  -c  -m  -b -q  -H  -h  -e. <br />Additional option (more difficult), expected to be done: handling regular expressions in grep. <br />Also Need to Submit: A file with tested commands - one per linne. File named as test.txt <br /><br /></p>
<h5><b>* diff</b></h5>
<p>Implement the patch command as well. <br />Following options:  -y  -c  -r  -t  -w  -b -i <br />Hint: Know the maximum common subsequence problem and solve it. <br />Also Need to Submit: A file with tested commands - one per linne. File named as test.txt <br /><br /></p>
<h5>* Sudoku</h5>
<p>Program should be able to (a) Generate a sudoku and offer to user for solving (b) Users to solve a sudoku (c) Save a partially solved Sudoku in a file (d) Resume a Sudoku from a saved file (e) Solve a user input Sudoku (user will input in a file, or using your UI) (f) Auto solve a partially solved Sudoku (g) Give Hints to users  (h) Have configuration options on size of sudoku (m x m, upto 25) and also difficulty level (no. of slots already filled in  (i) use a graphical interface using GTK or QT <br /><br /></p>
<h5><b>* File format converters</b></h5>
<p>E.g. JPG to BMP, ODT to PDF, etc. <br />The programs should be able to handle all files of the source type. They should also offer options as given by the "convert" utility on Linux. (The options depend on the file types). <br /><br /><b>* Text Editor:</b><br />The editor should have interface of nano or vi. <br /><br />Features required:  type a file, use tab, newline, save file, open a new file, open existing file, navigate (line up, line down, char left, char right, page up, page down), insert text (before, after in the middle, etc -anywhere),  copy-paste, cut-paste, search, search and replace.<br /><br />Notes: You may use the ncurses library or the termio library.</p>
<h3></h3>
<h4><span style="color: #ff0000; font-size: medium;"><b>Important points About Each Project<br /></b></span></h4>
<p>* The project should be a software that can REALLY be used for some real life work.<br />* If you are implementing any existing Unix commands then the behaviour of your software should be exactly like the existing command.<br />* If you are implmementing a GUI based software, then the design of user interface is a crucial factor in your evaluation. The user interface should be easy, intuitive. <br />* Some of the projects require you to write a test-suite. Some require specifying all the tested inputs in a text file.</p>
<p>* Imp: You should work on the design of your project first. Write down all the ADTs that you will need. Write down all the function prototypes for the functions that you plan to write. Show it to Abhijit once (by around 20th Sep).</p>
<h4><span style="color: #ff0000; font-size: medium;">On Writing a test-suite<br /></span></h4>
<p>* Some projects (FILE * library, malloc and free library, etc. ) require writing a test suite. It is mentioned against those projects which require a test-suite. Typically it is required for libraries. <br />* The test suite is a set of programs (written in C or Shell or C + Shell, etc). The tester runs only one program and that program in turn runs other programs. Each program tests one or more functionality of the software and reports success/failure. <br />* You are supposed to write an extensive test-suite for testin your code. <br />* You will also be judged on the quality of the test-suite. <br /><br /></p>
<h4><span style="color: #ff0000; font-size: medium;"><b>Tips to those implementing unix commands<br /></b></span></h4>
<p>* Useful C library functions:  getopt(for handling command line options), opendir(opening a directory),  readdir(reading a directory), stat(), chmod(), chown(),  mkdir(),  tmpnam(), tmpfile()<br />* Pay special attention to design of a data structure for storing the data. For example n-way tree, stack, stack of strings, array of strings, etc. <br />* Pay special attention to design of how to combine various options together. Normally if you don't do this in the begining, your code will become very complex.</p>
<h4><span style="color: #ff0000; font-size: medium;"><b>Projects Tasks and Submission Process<br /></b></span></h4>
<p><br />Given below is a detailed description of expectations from various projects, and the submission process: <br /><br /></p>
<h4>Submission Process:</h4>
<p>a) create your own account on http://gitlab.com  or http://git.fosscommunity.in  (henceforth called 'server') <br />b) create a<i> private (IMP, private!)</i> repository on the server. Give a good name to the repo<br />c) Create a README.md file in the repo describing your project<br />d) Add the user abhijit13 with permissions as 'master' to your project<br />d) Submit the git clone link (with the ".git" in the end) on moodle. E.g. the link looks like this:<br />https://gitlab.com/abhijit13/taasika.git<br />e) create your own pair of ssh-keys usinng ssh-keygen. Submit your own public key on server to enable write access for yourself.  <br />READ: <br />https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html<br /><br /></p>
<h4>Intermediate and continuous evaluation:</h4>
<p>* Learn git on your own. Minimum following commands need to be learnt: <br />  init, add, commit, push, pull, rm, branch, checkout<br />* Keep pushing your code to the server every 2-3 days. <br />  Abhijit will keep 'pull'ing your code and checking the   'master' branch. <br /><br /></p>
<p></p>